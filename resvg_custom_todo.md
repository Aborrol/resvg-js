# TODO: Кастомные доработки resvg

Этот чек-лист и документация описывают шаги по расширению функциональности resvg для поддержки кастомных шрифтов из буфера и автоматического переноса строк в SVG-тексте.

---

## 1. Поддержка передачи буферов шрифтов в Node.js

**Цель:**
Позволить передавать в resvg массив объектов с буферами шрифтов и явным именем family, чтобы не полагаться на встроенное имя в TTF/OTF-файле.

**API (JS):**
```js
const resvg = new Resvg(svg, {
  font: {
    fontBuffers: [
      { fontName: 'Arial', buffer: arialBuffer },
      { fontName: 'Roboto', buffer: robotoBuffer },
      // ...
    ],
    // остальные опции (loadSystemFonts, fontFiles, ...)
  },
  // ...
})
```

**Шаги:**
- [x] 1.1. Расширить структуру опций JS/Rust для массива `{ fontName, buffer }`:
  - Изменить `JsFontOptions` (JS и Rust) — добавить поле `fontBuffers` (массив объектов).
  - Прокинуть это поле через napi в Rust.
- [x] 1.2. Реализовать загрузку шрифтов из буфера с явным именем:
  - Для каждого объекта из массива вызывать `fontdb.load_font_data(buffer)`.
- [~] 1.3. (Пропущено) Использовать имя из поля `fontName` для сопоставления family name:
  - **Невозможно реализовать:** В используемой версии fontdb нельзя явно задать family name через API. Имя шрифта всегда берётся из TTF/OTF-файла при загрузке. Поле `fontName` в JS используется только для удобства, но не влияет на итоговое сопоставление. Для задания кастомного family name нужно изменить его внутри TTF/OTF-файла (например, через FontForge или fonteditor-core).
- [x] 1.4. Оставить обратную совместимость с загрузкой из файлов/директорий:
  - Старые поля (`fontFiles`, `fontDirs`, `loadSystemFonts`) работают как раньше.
- [x] 1.5. Добавить тесты и пример использования:
  - Покрыты кейсы: только буферы, только файлы, смешанный режим, несуществующий family name.
  - Добавлено подробное логирование подключённых шрифтов (logLevel: 'debug').

---

## 2. Многострочный текст (автоматический перенос)

**Цель:**
Реализовать автоматический перенос строк для `<text>`, если у него нет дочерних `<tspan>`, с учётом ширины, lineHeight, maxlines и символов переноса строки.

**SVG-пример:**
```svg
<text id="main-title" x="10" y="20" width="200" lineHeight="24" maxlines="3">...
</text>
```

**Опции layout:**
- Теперь структура `textLayout` (в JS-опциях) — это map: id `<text>` → объект опций.
- В объекте опций можно перезаписывать любые SVG-атрибуты (`x`, `y`, `font-family`, `font-size`, `fill`, `font-weight`, `font-style` и др.), а также layout-параметры (`width`, `lineHeight`, `maxlines`, `textAlign`).
- Если опция указана — она имеет приоритет над значением из SVG.

**Шаги:**
- [x] 2.1.1. Найти место в Rust-коде, где происходит layout текста для SVG `<text>`
  - Место для внедрения кастомного layout: после парсинга SVG и до вызова tree.convert_text(&fontdb) в функции Resvg::new_inner (src/lib.rs).
- [x] 2.1.2. Добавить парсинг атрибутов `width`, `lineHeight`, `maxlines`, `text-anchor` у `<text>`
  - Реализован обход дерева, логируются стандартные и кастомные атрибуты <text>.
  - Теперь поддерживается сопоставление по id и перезапись любых SVG-атрибутов через опции.
- [x] 2.1.3. Реализовать разбиение текста на строки (greedy word wrap):
  - [x] 2.1.3.1. Сначала делить текст на параграфы по символам `\n` (каждый параграф — отдельный блок переноса).
  - [x] 2.1.3.2. Реализовать функцию измерения ширины строки с учётом выбранного TTF-шрифта и размера (использовать fontdb + fontdue или аналогичную библиотеку). Поддерживать только TTF. Оптимизация и кэширование — опционально, если потребуется. WASM-версия не поддерживается.
  - [x] 2.1.3.3. Для каждого параграфа разбивать на строки по словам (жадный алгоритм):
        - Добавлять слово к строке, пока строка помещается по ширине (font metrics).
        - Если слово не помещается — переносить на новую строку.
        - Если само слово длиннее контейнера — переносить по символам (посимвольный wrap только для длинных слов).
  - [x] 2.1.3.4. Ограничивать по `maxlines`, при необходимости добавлять `...` к последней строке.
  - [x] 2.1.3.5. character-based wrap для CJK и др. не реализуется (не требуется).
- [x] 2.1.4. Реализовать вертикальное позиционирование с учётом `lineHeight`
- [x] 2.1.5. Реализовать горизонтальное центрирование (text-anchor: middle/center)
- [x] 2.1.6. Добавить логирование для отладки (параметры layout, итоговые строки)
- [ ] 2.1.7. Добавить тесты и пример SVG
- [ ] 2.2. Только для `<text>` без `<tspan>`:
  - Если есть `<tspan>`, использовать существующую логику.
- [ ] 2.3. Оставить существующую логику для `<tspan>`:
  - Не менять поведение для сложных SVG с вложенными `<tspan>`.
- [ ] 2.4. Добавить тесты и примеры SVG:
  - Кейсы: длинный текст, перенос по ширине, перенос по `\n`, ограничение по строкам, разные `lineHeight`.

---

## 3. Документация и обратная совместимость

**Цель:**
Обеспечить понятность новых опций и корректную работу старых сценариев.

**Шаги:**
- [ ] 3.1. Описать новые опции в README:
  - Примеры использования новых полей в JS и SVG.
  - Описание ограничений и fallback-логики.
- [ ] 3.2. Проверить обратную совместимость:
  - Старые тесты должны проходить без изменений.
  - Новые опции не должны ломать старое API.

---

**Примечание:**
- Все изменения должны быть покрыты тестами и примерами.
- Если потребуется — добавить флаг для отключения новой логики (feature flag). 

**Пример вызова Resvg с textLayout:**

```js
const resvg = new Resvg(svg, {
  textLayout: {
    "main-title": {
      width: 300,
      lineHeight: 32,
      maxlines: 3,
      textAlign: "center",
      opacity: 0.5,
      letterSpacing: 2.5,
      x: 50, // перезапишет x в <text id="main-title">
      y: 100, // перезапишет y
      fontFamily: "Lobster", // перезапишет font-family
      fontSize: 48, // перезапишет font-size
      fill: "#ff0000", // перезапишет цвет
    },
    "subtitle": {
      width: 200,
      lineHeight: 24,
      maxlines: 2,
      textAlign: "left",
    }
  },
  // остальные опции...
})
```

- Для `<text id="main-title">` будут применены все указанные параметры, даже если в SVG другие значения.
- Для `<text id="subtitle">` — свои параметры.
- Если id не найден — опции не применяются.

@https://docs.cursor.com/context/rules  создай в проекте правила, по которым ты будешь понимать контекст и не забудешь что ты делаешь со всеми деталями. Так же изучи @https://github.com/tyrchen/cursor-rust-rules

---

## 4. Решение проблемы установки платформо-зависимых пакетов

**Проблема:**
Пользователи получают ошибку `MODULE_NOT_FOUND` при использовании пакета, потому что платформо-зависимые модули не устанавливаются автоматически.

**Причина:**
Мы убрали `optionalDependencies` из package.json чтобы избежать циклической зависимости в CI, но это привело к проблемам для конечных пользователей.

**Решение:**
- [x] 4.1. Создать postinstall скрипт для автоматической установки платформо-зависимого пакета
- [x] 4.2. Создать ручной скрипт `install-platform` для случаев, когда postinstall не сработал
- [x] 4.3. Обновить README с инструкциями по установке
- [x] 4.4. Не добавлять `optionalDependencies` в основной package.json (избегаем проблем с CI)

**Реализовано:**
- `scripts/postinstall.js` - автоматически запускается после `npm install`
- `scripts/install-platform.js` - ручная установка платформо-зависимого пакета
- Обновлен README с подробными инструкциями
- Добавлен npm script `npm run install-platform`

**Результат:**
Теперь пользователи могут:
1. Установить основной пакет: `npm install @aborrol/resvg-js-tolty`
2. Платформо-зависимый пакет установится автоматически через postinstall
3. Если автоматическая установка не сработала - запустить `npm run install-platform`
4. Или установить вручную: `npm install @aborrol/resvg-js-tolty-darwin-x64` (для macOS Intel)